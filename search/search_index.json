{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"filters/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/laminas-i18n/filters/introduction/'; });","title":"_filters"},{"location":"introduction/","text":"Introduction Laminas\\I18n comes with a complete translation suite which supports all major formats and includes popular features like plural translations and text domains. The Translator component is mostly dependency free, except for the fallback to a default locale, where it relies on the Intl PHP extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will actually do nothing but just return the given message IDs.","title":"Introduction"},{"location":"introduction/#introduction","text":"Laminas\\I18n comes with a complete translation suite which supports all major formats and includes popular features like plural translations and text domains. The Translator component is mostly dependency free, except for the fallback to a default locale, where it relies on the Intl PHP extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will actually do nothing but just return the given message IDs.","title":"Introduction"},{"location":"translation/","text":"Translation laminas-i18n comes with a complete translation suite supporting all major formats and including popular features such as plural translations and text domains. The Translator subcomponent is mostly dependency free, except for the fallback to a default locale, where it relies on the PHP's intl extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will do nothing but return all messages verbatim. Adding translations Two options exist for adding translations to the translator: Add every translation file individually; use this for translation formats that store multiple locales in the same file. Add translation files based on a pattern; use this for formats that use one file per locale. To add a single file to the translator, use the addTranslationFile() method: use Laminas\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFile($type, $filename, $textDomain, $locale); where the arguments are: $type : the name of the format loader to use; see the next section for details. $filename : the file containing translations. $textDomain : a \"category\" name for translations. If this is omitted, it defaults to \"default\". Use text domains to segregate translations by context. $locale : the language strings are translated from; this argument is only required for formats which contain translations for single locales. When storing one locale per file, you should specify those files via a pattern. This allows you to add new translations to the file system, without touching your code. Patterns are added with the addTranslationFilePattern() method: use Laminas\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain); where the arguments are roughly the same as for addTranslationFile() , with a few differences: $baseDir is a directory containing translation files. $pattern is an sprintf() -formatted string describing a pattern for locating files under $baseDir . The $pattern should contain a substitution character for the $locale \u2014 which is omitted from the addTranslationFilePattern() call, but passed whenever a translation is requested. Use either %s or %1$s in the $pattern as a placeholder for the locale. As an example, if your translation files are located in /var/messages/<LOCALE>/messages.mo , your pattern would be /var/messages/%s/messages.mo . Supported formats The translator supports the following major translation formats: PHP arrays Gettext INI Additionally, you can use custom formats by implementing one or more of Laminas\\I18n\\Translator\\Loader\\FileLoaderInterface or Laminas\\I18n\\Translator\\Loader\\RemoteLoaderInterface , and registering your loader with the Translator instance's composed plugin manager. Setting a locale By default, the translator will get the locale to use from ext/intl's Locale class. If you want to set an alternative locale explicitly, you can do so by passing it to the setLocale() method. When there is no translation for a specific message identifier in a locale, the message identifier itself will be returned by default. Alternately, you can set a fallback locale which is used to retrieve a fallback translation. To do so, pass it to the setFallbackLocale() method. Translating messages Translating messages is accomplished by calling the translate() method of the translator: $translator->translate($message, $textDomain, $locale); The message is the message identifier to translate. If it does not exist in the loader, or is empty, the original message ID will be returned. The text domain parameter is the one you specified when adding translations. If omitted, the \"default\" text domain will be used. The locale parameter will usually not be used in this context, as by default the locale is taken from the locale set in the translator. To translate plural messages, you can use the translatePlural() method. It works similarly to translate() , but instead of a single message, it takes a singular value, a plural value, and an additional integer number on which the returned plural form is based: $translator->translatePlural($singular, $plural, $number, $textDomain, $locale); Plural translations are only available if the underlying format supports the translation of plural messages and plural rule definitions.","title":"Translation"},{"location":"translation/#translation","text":"laminas-i18n comes with a complete translation suite supporting all major formats and including popular features such as plural translations and text domains. The Translator subcomponent is mostly dependency free, except for the fallback to a default locale, where it relies on the PHP's intl extension. The translator itself is initialized without any parameters, as any configuration to it is optional. A translator without any translations will do nothing but return all messages verbatim.","title":"Translation"},{"location":"translation/#adding-translations","text":"Two options exist for adding translations to the translator: Add every translation file individually; use this for translation formats that store multiple locales in the same file. Add translation files based on a pattern; use this for formats that use one file per locale. To add a single file to the translator, use the addTranslationFile() method: use Laminas\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFile($type, $filename, $textDomain, $locale); where the arguments are: $type : the name of the format loader to use; see the next section for details. $filename : the file containing translations. $textDomain : a \"category\" name for translations. If this is omitted, it defaults to \"default\". Use text domains to segregate translations by context. $locale : the language strings are translated from; this argument is only required for formats which contain translations for single locales. When storing one locale per file, you should specify those files via a pattern. This allows you to add new translations to the file system, without touching your code. Patterns are added with the addTranslationFilePattern() method: use Laminas\\I18n\\Translator\\Translator; $translator = new Translator(); $translator->addTranslationFilePattern($type, $baseDir, $pattern, $textDomain); where the arguments are roughly the same as for addTranslationFile() , with a few differences: $baseDir is a directory containing translation files. $pattern is an sprintf() -formatted string describing a pattern for locating files under $baseDir . The $pattern should contain a substitution character for the $locale \u2014 which is omitted from the addTranslationFilePattern() call, but passed whenever a translation is requested. Use either %s or %1$s in the $pattern as a placeholder for the locale. As an example, if your translation files are located in /var/messages/<LOCALE>/messages.mo , your pattern would be /var/messages/%s/messages.mo .","title":"Adding translations"},{"location":"translation/#supported-formats","text":"The translator supports the following major translation formats: PHP arrays Gettext INI Additionally, you can use custom formats by implementing one or more of Laminas\\I18n\\Translator\\Loader\\FileLoaderInterface or Laminas\\I18n\\Translator\\Loader\\RemoteLoaderInterface , and registering your loader with the Translator instance's composed plugin manager.","title":"Supported formats"},{"location":"translation/#setting-a-locale","text":"By default, the translator will get the locale to use from ext/intl's Locale class. If you want to set an alternative locale explicitly, you can do so by passing it to the setLocale() method. When there is no translation for a specific message identifier in a locale, the message identifier itself will be returned by default. Alternately, you can set a fallback locale which is used to retrieve a fallback translation. To do so, pass it to the setFallbackLocale() method.","title":"Setting a locale"},{"location":"translation/#translating-messages","text":"Translating messages is accomplished by calling the translate() method of the translator: $translator->translate($message, $textDomain, $locale); The message is the message identifier to translate. If it does not exist in the loader, or is empty, the original message ID will be returned. The text domain parameter is the one you specified when adding translations. If omitted, the \"default\" text domain will be used. The locale parameter will usually not be used in this context, as by default the locale is taken from the locale set in the translator. To translate plural messages, you can use the translatePlural() method. It works similarly to translate() , but instead of a single message, it takes a singular value, a plural value, and an additional integer number on which the returned plural form is based: $translator->translatePlural($singular, $plural, $number, $textDomain, $locale); Plural translations are only available if the underlying format supports the translation of plural messages and plural rule definitions.","title":"Translating messages"},{"location":"validators/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/laminas-i18n/validators/introduction/'; });","title":"_validators"},{"location":"view-helpers/","text":"View Helpers laminas-i18n ships with a set of laminas-view helper classes related to internationalization: e.g., formatting a date, formatting currency, or displaying translated content. See the laminas-view helpers documentation for more information. IDE auto-completion in templates The Laminas\\I18n\\View\\HelperTrait trait can be used to provide auto-completion for modern IDEs. It defines the aliases of the view helpers in a DocBlock as @method tags. Usage In order to allow auto-completion in templates, $this variable should be type-hinted via a DocBlock at the top of your template. It is recommended that you always add the Laminas\\View\\Renderer\\PhpRenderer as the first type, so that the IDE can auto-suggest the default view helpers from laminas-view . Next, chain the HelperTrait from laminas-i18n with a pipe symbol (a.k.a. vertical bar) | : $$$$FENCED_CODE_BLOCK_5e70df4c292c22.92602108 You may chain as many HelperTrait traits as you like, depending on view helpers from which Laminas component you are using and would like to provide auto-completion for. CurrencyFormat Helper The CurrencyFormat view helper can be used to simplify rendering of localized currency values. It acts as a wrapper for the NumberFormatter class within the internationalization extension (ext/intl). Basic Usage // Within your view: echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'EUR', null, 'de_DE'); // Returns: \"1.234,56 \u20ac\" echo $this->currencyFormat(1234.56, 'USD', true, 'en_US'); // Returns: \"$1,234.56\" echo $this->currencyFormat(1234.56, 'USD', false, 'en_US'); // Returns: \"$1,235\" echo $this->currencyFormat(12345678.90, 'EUR', true, 'de_DE', '#0.# kg'); // Returns: \"12345678,90 kg\" echo $this->currencyFormat(12345678.90, 'EUR', false, 'de_DE', '#0.# kg'); // Returns: \"12345679 kg\" Method description currencyFormat( float $number [, string $currencyCode = null [, bool $showDecimals = null [, string $locale = null [, string $pattern = null ] ] ] ]) : string where: $number : the numeric currency value. $currencyCode : the 3-letter ISO 4217 currency code indicating the currency to use. If unset, it will use the default value current in the helper instance ( null by default). $showDecimals : Boolean false indicates that no decimals should be represented. If unset, it will use the value current in the helper instance ( true by default). $locale : Locale in which the currency would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (default is the value of Locale::getDefault() ). $pattern : Pattern string the formatter should use. If unset, it will use the value current in the helper instance ( null by default). Available Functionality Set the currency code and the locale The $currencyCode and $locale options can be set prior to formatting and will be applied each time the helper is used: // Within your view $this->plugin('currencyformat')->setCurrencyCode('USD')->setLocale('en_US'); echo $this->currencyFormat(1234.56); // This returns: \"$1,234.56\" echo $this->currencyFormat(5678.90); // This returns: \"$5,678.90\" The method signatures are: setCurrencyCode(string $currencyCode) : CurrencyFormat where $currencyCode is the 3-letter ISO 4217 currency code, and setLocale(string $locale) : CurrencyFormat where $locale is the locale with which to format the number. Show decimals // Within your view $this->plugin('currencyformat')->setShouldShowDecimals(false); echo $this->currencyFormat(1234.56, 'USD', null, 'en_US'); // This returns: \"$1,235\" with the following method signature: setShouldShowDecimals(bool $showDecimals) : CurrencyFormat where $showDecimals indicates whether or not decimal values will be displayed. Set the currency pattern // Within your view $this->plugin('currencyformat')->setCurrencyPattern('#0.# kg'); echo $this->currencyFormat(12345678.90, 'EUR', null, 'de_DE'); // This returns: \"12345678,90 kg\" with the following method signature: setCurrencyPattern(string $currencyPattern) : CurrencyFormat where $currencyPattern is a valid ICU DecimalFormat pattern ; see the NumberFormatter::setPattern() documentation for more information. DateFormat Helper The DateFormat view helper can be used to simplify rendering of localized date/time values. It acts as a wrapper for the IntlDateFormatter class within ext/intl. Basic Usage // Within your view // Date and Time echo $this->dateFormat( new DateTime(), IntlDateFormatter::MEDIUM, // date IntlDateFormatter::MEDIUM, // time \"en_US\" ); // This returns: \"Jul 2, 2012 6:44:03 PM\" // Date Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::LONG, // date IntlDateFormatter::NONE, // time \"en_US\" ); // This returns: \"July 2, 2012\" // Time Only echo $this->dateFormat( new DateTime(), IntlDateFormatter::NONE, // date IntlDateFormatter::SHORT, // time \"en_US\" ); // This returns: \"6:44 PM\" Method description dateFormat( mixed $date [, int $dateType = null [, int $timeType = null [, string $locale = null ] ] ]) : string where: $date : The value to format. This may be a DateTime instance, an integer representing a Unix timestamp value, or an array in the format returned by localtime() . $dateType : Date type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $timeType : Time type to use (none, short, medium, long, full). This is one of the IntlDateFormatter constants . Defaults to IntlDateFormatter::NONE . $locale : Locale in which the date would be formatted (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Public Methods The $locale option can be set prior to formatting with the setLocale() method and will be applied each time the helper is used. By default, the system's default timezone will be used when formatting. This overrides any timezone that may be set inside a DateTime object. To change the timezone when formatting, use the setTimezone() method. // Within your view $this->plugin('dateFormat') ->setTimezone('America/New_York') ->setLocale('en_US'); echo $this->dateFormat(new DateTime(), IntlDateFormatter::MEDIUM); // \"Jul 2, 2012\" echo $this->dateFormat(new DateTime(), IntlDateFormatter::SHORT); // \"7/2/12\" NumberFormat Helper The NumberFormat view helper can be used to simplify rendering of locale-specific number and/or percentage strings. It acts as a wrapper for the NumberFormatter class within ext/intl. Basic Usage // Within your view // Example of Decimal formatting: echo $this->numberFormat( 1234567.891234567890000, NumberFormatter::DECIMAL, NumberFormatter::TYPE_DEFAULT, 'de_DE' ); // This returns: \"1.234.567,891\" // Example of Percent formatting: echo $this->numberFormat( 0.80, NumberFormatter::PERCENT, NumberFormatter::TYPE_DEFAULT, 'en_US' ); // This returns: \"80%\" // Example of Scientific notation formatting: echo $this->numberFormat( 0.00123456789, NumberFormatter::SCIENTIFIC, NumberFormatter::TYPE_DEFAULT, 'fr_FR' ); // This returns: \"1,23456789E-3\" Method description numberFormat( int|float $number [, int $formatStyle = null [, int $formatType = null [, string $locale = null [, int $decimals = null [, array $textAttributes = null ] ] ] ] ]) : string where: $number : the number to format. $formatStyle : one of the NumberFormatter styles: NumberFormatter::DECIMAL , NumberFormatter::CURRENCY , etc. $formatType : one of the NumberFormatter types: NumberFormatter::TYPE_DEFAULT (basic numeric), NumberFormatter::TYPE_CURRENCY , etc. $locale : a valid locale to use when formatting the number. $decimals : the number of digits beyond the decimal point to display. $textAttributes : text attributes to use with the number (e.g., prefix and/or suffix for positive/negative numbers, currency code): NumberFormatter::POSITIVE_PREFIX , NumberFormatter::NEGATIVE_PREFIX , etc. Public Methods Each of the $formatStyle , $formatType , $locale , and $textAttributes options can be set prior to formatting and will be applied each time the helper is used. // Within your view $this->plugin(\"numberformat\") ->setFormatStyle(NumberFormatter::PERCENT) ->setFormatType(NumberFormatter::TYPE_DOUBLE) ->setLocale(\"en_US\") ->setTextAttributes([ NumberFormatter::POSITIVE_PREFIX => '^ ', NumberFormatter::NEGATIVE_PREFIX => 'v ', ]); echo $this->numberFormat(0.56); // \"^ 56%\" echo $this->numberFormat(-0.90); // \"v 90%\" Plural Helper Most languages have specific rules for handling plurals. For instance, in English, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular). On the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\" and \"1 voiture\") and the plural form otherwise (\"3 voitures\"). Therefore we often need to handle plural cases even without translation (mono-lingual application). The Plural helper was created for this. Plural helper does not translate If you need to handle both plural cases and translations, you must use the TranslatePlural helper; Plural does not translate. Internally, the Plural helper uses the Laminas\\I18n\\Translator\\Plural\\Rule class to handle rules. Setup Defining plural rules is left to the developer. To help you with this process, here are some links with up-to-date plural rules for tons of languages: http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html https://developer.mozilla.org/en-US/docs/Localization_and_Plurals Basic Usage First, define a rule. As an example, you could add the following code in your Module class: // Get the ViewHelperPlugin Manager from the ServiceManager, so we can fetch the // Plural helper and add the plural rule for the application's language: $viewHelperManager = $serviceManager->get('ViewHelperManager'); $pluralHelper = $viewHelperManager->get('Plural'); // Here is the rule for French $pluralHelper->setPluralRule('nplurals=2; plural=(n==0 || n==1 ? 0 : 1)'); The string reads as follows: First, we specify how many plural forms we have. For French, only two (singular/plural). Next, we specify the rule. Here, if the count is 0 or 1, this is rule n\u00b00 (singular) while it's rule n\u00b01 otherwise. As noted earlier earlier, English considers \"1\" as singular and \"0/other\" as plural. Here is how that would be declared: // Here is the rule for English $pluralHelper->setPluralRule('nplurals=2; plural=(n==1 ? 0 : 1)'); Now that we have defined the rule, we can use it in our views: // Within a view script... // If the rule defined in Module.php is the English one: echo $this->plural(array('car', 'cars'), 0); // prints \"cars\" echo $this->plural(array('car', 'cars'), 1); // prints \"car\" // If the rule defined in Module.php is the French one: echo $this->plural(array('voiture', 'voitures'), 0); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 1); // prints \"voiture\" echo $this->plural(array('voiture', 'voitures'), 2); // prints \"voitures\" Translate Helper The Translate view helper can be used to translate content. It acts as a wrapper for the Laminas\\I18n\\Translator\\Translator class. Setup Before using the Translate view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Laminas\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you. Basic Usage // Within your view... echo $this->translate(\"Some translated text.\"); echo $this->translate(\"Translated text from a custom text domain.\", \"customDomain\"); echo sprintf($this->translate(\"The current time is %s.\"), $currentTime); echo $this->translate(\"Translate in a specific locale\", \"default\", \"de_DE\"); Method description translate( string $message [, string $textDomain = null [, string $locale = null ] ]) : string where: $message : The message to translate. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Gettext The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information. Public Methods Public methods for setting a Laminas\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper . TranslatePlural Helper The TranslatePlural view helper can be used to translate words which take into account numeric meanings. English, for example, has a singular definition of \"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\" or more than one car. Other languages like Russian or Polish have more plurals with different rules. The helper acts as a wrapper for the Laminas\\I18n\\Translator\\Translator class. Setup Before using the TranslatePlural view helper, you must have first created a Translator object and have attached it to the view helper. If you use the Laminas\\View\\HelperPluginManager to invoke the view helper, this will be done automatically for you. Basic Usage // Within your view echo $this->translatePlural(\"car\", \"cars\", $num); // Use a custom domain echo $this->translatePlural(\"monitor\", \"monitors\", $num, \"customDomain\"); // Change locale echo $this->translatePlural(\"locale\", \"locales\", $num, \"default\", \"de_DE\"); Method description translatePlural( string $singular, string $plural, int $number [, string $textDomain = null [, string $locale = null ] ]) : string where: $singular : The message to use for singular values. $plural : The message to use for plural values. $number : The number to evaluate in order to determine which number to use. $textDomain : The text domain/context of the translation; defaults to \"default\". $locale : Locale to which the message should be translated (locale name, e.g. en_US ). If unset, it will use the default locale (return value of Locale::getDefault() ). Gettext The xgettext utility can be used to compile *.po files from PHP source files containing the translate view helper. $ xgettext --language=php --add-location --keyword=translate --keyword=translatePlural:1,2 my-view-file.phtml See the Gettext Wikipedia page for more information. Public Methods Public methods for setting a Laminas\\I18n\\Translator\\Translator and a default text domain are inherited from the AbstractTranslatorHelper . Abstract Translator Helper The AbstractTranslatorHelper view helper is used as a base abstract class for any helpers that need to translate content. It provides an implementation for the Laminas\\I18n\\Translator\\TranslatorAwareInterface , allowing translator injection as well as text domain injection. Public Methods setTranslator() setTranslator( Translator $translator [ , string $textDomain = null ] ) : void Sets the Laminas\\I18n\\Translator\\Translator instance to use in the helper. The $textDomain argument is optional, and provided as a convenienct to allow setting both the translator and text domain simultaneously. getTranslator() getTranslator() : Translator Returns the Laminas\\I18n\\Translator\\Translator instance used by the helper. hasTranslator() hasTranslator() : bool Returns true if the helper composes a Laminas\\I18n\\Translator\\Translator instance. setTranslatorEnabled() setTranslatorEnabled(bool $enabled) : void Sets whether or not translations are enabled. isTranslatorEnabled() isTranslatorEnabled() : bool Returns true if translations are enabled. setTranslatorTextDomain() setTranslatorTextDomain(string $textDomain) : void Sets the default translation text domain to use with the helper. getTranslatorTextDomain() getTranslatorTextDomain() : string Returns the current text domain used by the helper.","title":"View Helpers"},{"location":"view-helpers/#view-helpers","text":"laminas-i18n ships with a set of laminas-view helper classes related to internationalization: e.g., formatting a date, formatting currency, or displaying translated content. See the laminas-view helpers documentation for more information.","title":"View Helpers"},{"location":"view-helpers/#currencyformat-helper","text":"The CurrencyFormat view helper can be used to simplify rendering of localized currency values. It acts as a wrapper for the NumberFormatter class within the internationalization extension (ext/intl).","title":"CurrencyFormat Helper"},{"location":"view-helpers/#dateformat-helper","text":"The DateFormat view helper can be used to simplify rendering of localized date/time values. It acts as a wrapper for the IntlDateFormatter class within ext/intl.","title":"DateFormat Helper"},{"location":"view-helpers/#numberformat-helper","text":"The NumberFormat view helper can be used to simplify rendering of locale-specific number and/or percentage strings. It acts as a wrapper for the NumberFormatter class within ext/intl.","title":"NumberFormat Helper"},{"location":"view-helpers/#plural-helper","text":"Most languages have specific rules for handling plurals. For instance, in English, we say \"0 cars\" and \"2 cars\" (plural) while we say \"1 car\" (singular). On the other hand, French uses the singular form for both 0 and 1 (\"0 voiture\" and \"1 voiture\") and the plural form otherwise (\"3 voitures\"). Therefore we often need to handle plural cases even without translation (mono-lingual application). The Plural helper was created for this.","title":"Plural Helper"},{"location":"view-helpers/#translate-helper","text":"The Translate view helper can be used to translate content. It acts as a wrapper for the Laminas\\I18n\\Translator\\Translator class.","title":"Translate Helper"},{"location":"view-helpers/#translateplural-helper","text":"The TranslatePlural view helper can be used to translate words which take into account numeric meanings. English, for example, has a singular definition of \"car\", for one car, and the plural definition, \"cars\", meaning zero \"cars\" or more than one car. Other languages like Russian or Polish have more plurals with different rules. The helper acts as a wrapper for the Laminas\\I18n\\Translator\\Translator class.","title":"TranslatePlural Helper"},{"location":"view-helpers/#abstract-translator-helper","text":"The AbstractTranslatorHelper view helper is used as a base abstract class for any helpers that need to translate content. It provides an implementation for the Laminas\\I18n\\Translator\\TranslatorAwareInterface , allowing translator injection as well as text domain injection.","title":"Abstract Translator Helper"},{"location":"application-integration/stand-alone/","text":"Stand-Alone All filters, validators, view-helpers and the translator of laminas-i18n can also be used stand-alone. Translator Setup Create a file for the translation messages. For example languages/de_DE.php : return [ 'car' => 'Auto', 'train' => 'Zug', ]; Create the translator instance and add the translation file. $translator = new Laminas\\I18n\\Translator\\Translator(); $translator->addTranslationFile( Laminas\\I18n\\Translator\\Loader\\PhpArray::class, __DIR__ . '/languages/de_DE.php', 'default', 'de_DE' ); Translate Messages $translator->setLocale('de_DE'); echo $translator->translate('car'); // Auto echo $translator->translate('train'); // Zug Filters Each filter can be used directly. $filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" Using Filter Plugin Manager Register all standard filters of laminas-i18n in the filter-plugin-manager: $filterManager = new Laminas\\Filter\\FilterPluginManager( new Laminas\\ServiceManager\\ServiceManager() ); $filterManager->configure( (new Laminas\\I18n\\ConfigProvider())->getFilterConfig() ); Get a filter: /** @var Laminas\\I18n\\Filter\\Alnum $filter */ $filter = $filterManager->get(Laminas\\I18n\\Filter\\Alnum::class); Validators Each validator can be used directly. $validator = new Laminas\\I18n\\Validator\\Alnum(); $result = $validator->isValid('Abcd12')); // true Using Validator Plugin Manager Register all standard validators of laminas-i18n in the validator-plugin-manager: $validatorManager = new Laminas\\Validator\\ValidatorPluginManager( new Laminas\\ServiceManager\\ServiceManager() ); $validatorManager->configure( (new Laminas\\I18n\\ConfigProvider())->getValidatorConfig() ); Get a validator: /** @var Laminas\\I18n\\Validator\\Alnum $validator */ $validator = $validatorManager->get(Laminas\\I18n\\Validator\\Alnum::class); View Helpers Setup laminas-view Create the renderer: $renderer = new Laminas\\View\\Renderer\\PhpRenderer(); Register all standard view-helpers of laminas-i18n in the helper-plugin-manager: $renderer->getHelperPluginManager()->configure( (new Laminas\\I18n\\ConfigProvider())->getViewHelperConfig() ); Using Helper echo $renderer->currencyFormat(1234.56, 'USD', null, 'en_US'); // \"$1,234.56\"","title":"Stand-Alone"},{"location":"application-integration/stand-alone/#stand-alone","text":"All filters, validators, view-helpers and the translator of laminas-i18n can also be used stand-alone.","title":"Stand-Alone"},{"location":"application-integration/stand-alone/#translator","text":"","title":"Translator"},{"location":"application-integration/stand-alone/#filters","text":"Each filter can be used directly. $filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\"","title":"Filters"},{"location":"application-integration/stand-alone/#validators","text":"Each validator can be used directly. $validator = new Laminas\\I18n\\Validator\\Alnum(); $result = $validator->isValid('Abcd12')); // true","title":"Validators"},{"location":"application-integration/stand-alone/#view-helpers","text":"","title":"View Helpers"},{"location":"filters/alnum/","text":"Alnum The Alnum filter can be used to return only alphabetic characters and digits in the unicode \"letter\" and \"number\" categories, respectively. All other characters are suppressed. Basic Usage $filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" By default, if no locale is provided, Alnum will use the system locale provided by PHP's Locale class and the getDefault() method. Using Whitespace To allow whitespace characters ( \\s ) on filtering set the option to true ; otherwise they are suppressed. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\Alnum(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content 123\" $filter = new Laminas\\I18n\\Filter\\Alnum(); $filter->setAllowWhiteSpace(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content 123\" Get Current Value To get the current value of this option, use the getAllowWhiteSpace() method. $filter = new Laminas\\I18n\\Filter\\Alnum(true); $result = $filter->getAllowWhiteSpace(); // true Default Value The default value of this option is false that means whitespace characters are suppressed. Using Locale The locale string used in identifying the characters to filter (locale name, e.g. en_US ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\Alnum(null, 'en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" $filter = new Laminas\\I18n\\Filter\\Alnum(); $filter->setLocale('en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" Locale::setDefault('en_US'); $filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" Get Current Value To get the current value of this option, use the getLocale() method. $filter = new Laminas\\I18n\\Filter\\Alnum(null, 'en_US'); echo $filter->getLocale(); // 'en_US' Default Value By default, if no locale is provided, Alnum will use the system locale provided by PHP's Locale::getDefault() . Supported Languages Alnum works for most languages, except Korean , Japanese , and Chinese . Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using PHP's Locale class.","title":"Alnum"},{"location":"filters/alnum/#alnum","text":"The Alnum filter can be used to return only alphabetic characters and digits in the unicode \"letter\" and \"number\" categories, respectively. All other characters are suppressed.","title":"Alnum"},{"location":"filters/alnum/#basic-usage","text":"$filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" By default, if no locale is provided, Alnum will use the system locale provided by PHP's Locale class and the getDefault() method.","title":"Basic Usage"},{"location":"filters/alnum/#using-whitespace","text":"To allow whitespace characters ( \\s ) on filtering set the option to true ; otherwise they are suppressed. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\Alnum(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content 123\" $filter = new Laminas\\I18n\\Filter\\Alnum(); $filter->setAllowWhiteSpace(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content 123\"","title":"Using Whitespace"},{"location":"filters/alnum/#using-locale","text":"The locale string used in identifying the characters to filter (locale name, e.g. en_US ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\Alnum(null, 'en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" $filter = new Laminas\\I18n\\Filter\\Alnum(); $filter->setLocale('en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\" Locale::setDefault('en_US'); $filter = new Laminas\\I18n\\Filter\\Alnum(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent123\"","title":"Using Locale"},{"location":"filters/alnum/#supported-languages","text":"Alnum works for most languages, except Korean , Japanese , and Chinese . Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using PHP's Locale class.","title":"Supported Languages"},{"location":"filters/alpha/","text":"Alpha The Alpha filter can be used to return only alphabetic characters in the unicode \"letter\" category. All other characters are suppressed. Basic Usage $filter = new Laminas\\I18n\\Filter\\Alpha(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" By default, if no locale is provided, Alpha will use the system locale provided by PHP's Locale class and the getDefault() method. Using Whitespace To allow whitespace characters ( \\s ) on filtering set the option to true ; otherwise they are suppressed. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\Alpha(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content\" $filter = new Laminas\\I18n\\Filter\\Alpha(); $filter->setAllowWhiteSpace(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content\" Get Current Value To get the current value of this option, use the getAllowWhiteSpace() method. $filter = new Laminas\\I18n\\Filter\\Alpha(true); $result = $filter->getAllowWhiteSpace(); // true Default Value The default value of this option is false that means whitespace characters are suppressed. Using Locale The locale string used in identifying the characters to filter (locale name, e.g. en_US ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\Alpha(null, 'en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" $filter = new Laminas\\I18n\\Filter\\Alpha(); $filter->setLocale('en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" Locale::setDefault('en_US'); $filter = new Laminas\\I18n\\Filter\\Alpha(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" Get Current Value To get the current value of this option, use the getLocale() method. $filter = new Laminas\\I18n\\Filter\\Alpha(null, 'en_US'); echo $filter->getLocale(); // 'en_US' Default Value By default, if no locale is provided, Alpha will use the system locale provided by PHP's Locale::getDefault() . Supported languages Alpha works for most languages, except Korean , Japanese , and Chinese . Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using PHP's Locale class.","title":"Alpha"},{"location":"filters/alpha/#alpha","text":"The Alpha filter can be used to return only alphabetic characters in the unicode \"letter\" category. All other characters are suppressed.","title":"Alpha"},{"location":"filters/alpha/#basic-usage","text":"$filter = new Laminas\\I18n\\Filter\\Alpha(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" By default, if no locale is provided, Alpha will use the system locale provided by PHP's Locale class and the getDefault() method.","title":"Basic Usage"},{"location":"filters/alpha/#using-whitespace","text":"To allow whitespace characters ( \\s ) on filtering set the option to true ; otherwise they are suppressed. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\Alpha(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content\" $filter = new Laminas\\I18n\\Filter\\Alpha(); $filter->setAllowWhiteSpace(true); echo $filter->filter('This is (my) content: 123'); // \"This is my content\"","title":"Using Whitespace"},{"location":"filters/alpha/#using-locale","text":"The locale string used in identifying the characters to filter (locale name, e.g. en_US ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\Alpha(null, 'en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" $filter = new Laminas\\I18n\\Filter\\Alpha(); $filter->setLocale('en_US'); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\" Locale::setDefault('en_US'); $filter = new Laminas\\I18n\\Filter\\Alpha(); echo $filter->filter('This is (my) content: 123'); // \"Thisismycontent\"","title":"Using Locale"},{"location":"filters/alpha/#supported-languages","text":"Alpha works for most languages, except Korean , Japanese , and Chinese . Within these languages, the English alphabet is used instead of the characters from these languages. The language itself is detected using PHP's Locale class.","title":"Supported languages"},{"location":"filters/introduction/","text":"Introduction laminas-i18n ships with a set of internationalization-related filters. Alnum Alpha NumberFormat NumberParse These filters are based on Laminas component for filtering and normalizing data and files: laminas-filter . The concept and the basic usage of the filters can be found in the documentation of laminas-filter . Installation requirements The filtering support of laminas-i18n depends on the laminas-filter component, so be sure to have it installed before getting started: $$$$FENCED_CODE_BLOCK_5e70df4c294a47.66064213","title":"Introduction"},{"location":"filters/introduction/#introduction","text":"laminas-i18n ships with a set of internationalization-related filters. Alnum Alpha NumberFormat NumberParse These filters are based on Laminas component for filtering and normalizing data and files: laminas-filter . The concept and the basic usage of the filters can be found in the documentation of laminas-filter .","title":"Introduction"},{"location":"filters/number-format/","text":"NumberFormat The NumberFormat filter can be used to return locale-specific number and percentage strings . It extends the NumberParse filter , which acts as wrapper for the NumberFormatter class within PHP's internationalization extension ( ext/intl ). Basic Usage $filter = new Laminas\\I18n\\Filter\\NumberFormat(); echo $filter->filter(1234567.8912346); // \"1.234.567,891\" By default, if no locale is provided, NumberParse will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to de_DE .) More Examples Format a number as percent: $filter = new Laminas\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT); echo $filter->filter(0.80); // \"80%\" Format a number in a scientific format: $filter = new Laminas\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter(0.00123456789); // \"1,23456789E-3\" Inherited Options and Methods The NumberFormat filter extends the NumberParse filter and supports the same options and methods for locale, style, type and formatter. The descriptions with examples of usage can be found there: Using Locale Setting Style Setting Type Setting Custom NumberFormatter","title":"NumberFormat"},{"location":"filters/number-format/#numberformat","text":"The NumberFormat filter can be used to return locale-specific number and percentage strings . It extends the NumberParse filter , which acts as wrapper for the NumberFormatter class within PHP's internationalization extension ( ext/intl ).","title":"NumberFormat"},{"location":"filters/number-format/#basic-usage","text":"$filter = new Laminas\\I18n\\Filter\\NumberFormat(); echo $filter->filter(1234567.8912346); // \"1.234.567,891\" By default, if no locale is provided, NumberParse will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to de_DE .)","title":"Basic Usage"},{"location":"filters/number-format/#inherited-options-and-methods","text":"The NumberFormat filter extends the NumberParse filter and supports the same options and methods for locale, style, type and formatter. The descriptions with examples of usage can be found there: Using Locale Setting Style Setting Type Setting Custom NumberFormatter","title":"Inherited Options and Methods"},{"location":"filters/number-parse/","text":"NumberParse The NumberParse filter can be used to parse a number from a string . It acts as a wrapper for the NumberFormatter class within PHP's internationalization extension ( ext/intl ). Basic Usage $filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->filter('1.234.567,891'); // 1234567.8912346 By default, if no locale is provided, NumberParse will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to de_DE .) Using Locale The locale string used in identifying the characters to filter (locale name, e.g. en_US or de_DE ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\NumberParse('de_DE'); echo $filter->filter('1.234.567,891'); // 1234567.8912346 $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setLocale('de_DE'); echo $filter->filter('1.234.567,891'); // 1234567.8912346 Locale::setDefault('de_DE'); $filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->filter('1.234.567,891'); // 1234567.8912346 Notice After the first filtering, the locale changes will have no effect anymore. Create a new instance of the filter to change the locale. Get Current Value To get the current value of this option, use the getLocale() method. $filter = new Laminas\\I18n\\Filter\\NumberParse('en_US'); echo $filter->getLocale(); // 'en_US' Default Value By default, if no locale is provided, NumberParse will use the system locale provided by PHP's Locale::getDefault() . Using Style This option sets the style of the parsing; one of the NumberFormatter format style constants . Constructor Usage Setter Usage // Example 1 $filter = new Laminas\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT); echo $filter->filter('80%'); // 0.80 // Example 2 $filter = new Laminas\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // 0.00123456789 // Example 1 $filter = new Laminas\\I18n\\Filter\\NumberParse('en_US'); $filter->setStyle(NumberFormatter::PERCENT); echo $filter->filter('80%'); // 0.80 // Example 2 $filter = new Laminas\\I18n\\Filter\\NumberParse('fr_FR'); $filter->setStyle(NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // 0.00123456789 Notice After the first filtering, the style changes will have no effect anymore. Create a new instance of the filter to change the style. Get Current Value To get the current value of this option, use the getStyle() method. $filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->getStyle(); // 1 (NumberFormatter::DEFAULT_STYLE) Default Value The default value of this option is NumberFormatter::DEFAULT_STYLE . Using Type The type speficied the NumberFormatter parsing type to use. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\NumberParse( 'de_DE', NumberFormatter::DEFAULT_STYLE, NumberFormatter::DECIMAL ); echo $filter->filter('1.234.567,891'); // 1234567 $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setLocale('de_DE'); $filter->setType(NumberFormatter::DECIMAL); echo $filter->filter('1.234.567,891'); // 1234567 Get Current Value To get the current value of this option, use the getType() method. $filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->getType(); // 3 (NumberFormatter::TYPE_DOUBLE) Default Value The default value of this option is NumberFormatter::TYPE_DOUBLE . Using Custom NumberFormatter $formatter = new NumberFormatter('en_US', NumberFormatter::PERCENT); $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setFormatter($formatter); Notice If a custom formatter is set, the locale and/or the style changes will have no effect anymore. Set a new number formatter to change the locale and/or the style. Get Current Value To get the current value of this option, use the getFormatter() method. $filter = new Laminas\\I18n\\Filter\\NumberParse(); $formatter = $filter->getFormatter(); // instance of `NumberFormatter` Default Value The default value of this option is an instance of PHP's NumberFormatter class. Created with the current values for locale and style of the filter.","title":"NumberParse"},{"location":"filters/number-parse/#numberparse","text":"The NumberParse filter can be used to parse a number from a string . It acts as a wrapper for the NumberFormatter class within PHP's internationalization extension ( ext/intl ).","title":"NumberParse"},{"location":"filters/number-parse/#basic-usage","text":"$filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->filter('1.234.567,891'); // 1234567.8912346 By default, if no locale is provided, NumberParse will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to de_DE .)","title":"Basic Usage"},{"location":"filters/number-parse/#using-locale","text":"The locale string used in identifying the characters to filter (locale name, e.g. en_US or de_DE ). Constructor Usage Setter Usage Locale Class Usage $filter = new Laminas\\I18n\\Filter\\NumberParse('de_DE'); echo $filter->filter('1.234.567,891'); // 1234567.8912346 $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setLocale('de_DE'); echo $filter->filter('1.234.567,891'); // 1234567.8912346 Locale::setDefault('de_DE'); $filter = new Laminas\\I18n\\Filter\\NumberParse(); echo $filter->filter('1.234.567,891'); // 1234567.8912346","title":"Using Locale"},{"location":"filters/number-parse/#using-style","text":"This option sets the style of the parsing; one of the NumberFormatter format style constants . Constructor Usage Setter Usage // Example 1 $filter = new Laminas\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT); echo $filter->filter('80%'); // 0.80 // Example 2 $filter = new Laminas\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // 0.00123456789 // Example 1 $filter = new Laminas\\I18n\\Filter\\NumberParse('en_US'); $filter->setStyle(NumberFormatter::PERCENT); echo $filter->filter('80%'); // 0.80 // Example 2 $filter = new Laminas\\I18n\\Filter\\NumberParse('fr_FR'); $filter->setStyle(NumberFormatter::SCIENTIFIC); echo $filter->filter('1,23456789E-3'); // 0.00123456789","title":"Using Style"},{"location":"filters/number-parse/#using-type","text":"The type speficied the NumberFormatter parsing type to use. Constructor Usage Setter Usage $filter = new Laminas\\I18n\\Filter\\NumberParse( 'de_DE', NumberFormatter::DEFAULT_STYLE, NumberFormatter::DECIMAL ); echo $filter->filter('1.234.567,891'); // 1234567 $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setLocale('de_DE'); $filter->setType(NumberFormatter::DECIMAL); echo $filter->filter('1.234.567,891'); // 1234567","title":"Using Type"},{"location":"filters/number-parse/#using-custom-numberformatter","text":"$formatter = new NumberFormatter('en_US', NumberFormatter::PERCENT); $filter = new Laminas\\I18n\\Filter\\NumberParse(); $filter->setFormatter($formatter);","title":"Using Custom NumberFormatter"},{"location":"migration/migration-to-v2.4/","text":"Migration from Versions prior to 2.4 General Version 2.4 adds support for PHP 7. Validators IsFloat In PHP 7, float is a reserved keyword, which required renaming the Laminas\\I18n\\Validator\\Float validator. If you were using the Laminas\\I18n\\Validator\\Float validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the Laminas\\I18n\\Validator\\IsFloat class instead. Users pulling their Laminas\\I18n\\Validator\\Float validator instance from the validator plugin manager receive an Laminas\\I18n\\Validator\\IsFloat instance instead starting in 2.4.0. IsInt In PHP 7, int is a reserved keyword, which required renaming the Laminas\\I18n\\Validator\\Int validator. If you were using the Laminas\\I18n\\Validator\\Int validator directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the Laminas\\I18n\\Validator\\IsInt class instead. Users pulling their Laminas\\I18n\\Validator\\Int validator instance from the validator plugin manager receive an Laminas\\I18n\\Validator\\IsInt instance instead starting in 2.4.0.","title":"Migration from Versions prior to 2.4"},{"location":"migration/migration-to-v2.4/#migration-from-versions-prior-to-24","text":"","title":"Migration from Versions prior to 2.4"},{"location":"migration/migration-to-v2.4/#general","text":"Version 2.4 adds support for PHP 7.","title":"General"},{"location":"migration/migration-to-v2.4/#validators","text":"","title":"Validators"},{"location":"translator/caching/","text":"Caching In production, it makes sense to cache your translations. This not only saves you from loading and parsing the individual formats each time, but also guarantees an optimized loading procedure. Installation requirements The cache support of laminas-i18n depends on the laminas-cache component, so be sure to have it installed before getting started: $$$$FENCED_CODE_BLOCK_5e70df4c28c6b6.37482110 Enable Caching To enable caching, pass a Laminas\\Cache\\Storage\\Adapter to the setCache() method. $translator = new Laminas\\I18n\\Translator\\Translator(); $cache = Laminas\\Cache\\StorageFactory::factory([ 'adapter' => [ 'name' => Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' => [ 'cache_dir' => __DIR__ . '/cache', ], ], ]); $translator->setCache($cache); The explanation of creating a cache and and using different adapters for caching can be found in documentation of laminas-cache . Disable Caching To disable the cache, pass a null value to the setCache() method. $translator->setCache(null); Clear Cache To clear the cache for a specific text domain and locale, use the clearCache method. $translator->clearCache('default', 'en_US'); Get Cache Identifier To get the cache identifier for a specific text domain and locale, use the getCacheId method: $translator->getCacheId('default', 'en_US');","title":"Caching"},{"location":"translator/caching/#caching","text":"In production, it makes sense to cache your translations. This not only saves you from loading and parsing the individual formats each time, but also guarantees an optimized loading procedure.","title":"Caching"},{"location":"translator/caching/#enable-caching","text":"To enable caching, pass a Laminas\\Cache\\Storage\\Adapter to the setCache() method. $translator = new Laminas\\I18n\\Translator\\Translator(); $cache = Laminas\\Cache\\StorageFactory::factory([ 'adapter' => [ 'name' => Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' => [ 'cache_dir' => __DIR__ . '/cache', ], ], ]); $translator->setCache($cache); The explanation of creating a cache and and using different adapters for caching can be found in documentation of laminas-cache .","title":"Enable Caching"},{"location":"translator/caching/#disable-caching","text":"To disable the cache, pass a null value to the setCache() method. $translator->setCache(null);","title":"Disable Caching"},{"location":"translator/caching/#clear-cache","text":"To clear the cache for a specific text domain and locale, use the clearCache method. $translator->clearCache('default', 'en_US');","title":"Clear Cache"},{"location":"translator/caching/#get-cache-identifier","text":"To get the cache identifier for a specific text domain and locale, use the getCacheId method: $translator->getCacheId('default', 'en_US');","title":"Get Cache Identifier"},{"location":"translator/factory/","text":"Factory Setting Locale $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'locale' => 'de_DE', ]); Setting Fallback Locale $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'locale' => [ 'de_DE', // Default locale 'en_GB', // Fallback locale ], ]); Setting Translation File Patterns $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'translation_file_patterns' => [ [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'base_dir' => __DIR__ . '/languages', 'pattern' => '%s.php', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'base_dir' => __DIR__ . '/languages', 'pattern' => 'album-%s.php', 'text_domain' => 'album', ], ], ]); Each file pattern option array must contain type , base_dir and pattern . The option for text_domain is optional. The default value for text_domain is default . Setting Translation Files $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'translation_files' => [ [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/en_GB.php', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/de_DE.php', 'locale' => 'de_DE', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/album-de_DE.php', 'locale' => 'de_DE', 'text_domain' => 'album', ], ], ]); Each file option array must contain type and filename . The options for locale and the text_domain are optional. The default value for locale is null and for text_domain it is default . Setting Remote Translations $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'remote_translation' => [ [ 'type' => 'translation-de_DE', // Custom name ], [ 'type' => 'translation-de_DE', // Custom name 'text_domain' => 'album', ], ], ]); Each remote option array must contain type . The option for text_domain is optional. The default value for text_domain is default . Adding Translations $translator->getPluginManager()->setService( 'translation-de_DE', // Custom name new \\Laminas\\I18n\\Translator\\Loader\\PhpMemoryArray([ 'default' => [ 'de_DE' => [ 'car' => 'Auto', 'train' => 'Zug', ], ], 'album' => [ 'de_DE' => [ 'music' => 'Musik', ], ], ]) ); Setting Cache Using a Cache Instance $cache = Laminas\\Cache\\StorageFactory::factory([ 'adapter' => [ 'name' => Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' => [ 'cache_dir' => __DIR__ . '/cache', ], ], ]); $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'cache' => $cache, ]); Using Cache Configuration $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'cache' => [ 'adapter' => [ 'name' => Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' => [ 'cache_dir' => __DIR__ . '/cache', ], ], ], ]); Enable EventManager $translator = Laminas\\I18n\\Translator\\Translator::factory([ 'event_manager_enabled' => true, ]);","title":"Factory"},{"location":"translator/factory/#factory","text":"","title":"Factory"},{"location":"translator/factory/#setting-locale","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'locale' => 'de_DE', ]);","title":"Setting Locale"},{"location":"translator/factory/#setting-fallback-locale","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'locale' => [ 'de_DE', // Default locale 'en_GB', // Fallback locale ], ]);","title":"Setting Fallback Locale"},{"location":"translator/factory/#setting-translation-file-patterns","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'translation_file_patterns' => [ [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'base_dir' => __DIR__ . '/languages', 'pattern' => '%s.php', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'base_dir' => __DIR__ . '/languages', 'pattern' => 'album-%s.php', 'text_domain' => 'album', ], ], ]); Each file pattern option array must contain type , base_dir and pattern . The option for text_domain is optional. The default value for text_domain is default .","title":"Setting Translation File Patterns"},{"location":"translator/factory/#setting-translation-files","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'translation_files' => [ [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/en_GB.php', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/de_DE.php', 'locale' => 'de_DE', ], [ 'type' => Laminas\\I18n\\Translator\\Loader\\PhpArray::class, 'filename' => __DIR__ . '/languages/album-de_DE.php', 'locale' => 'de_DE', 'text_domain' => 'album', ], ], ]); Each file option array must contain type and filename . The options for locale and the text_domain are optional. The default value for locale is null and for text_domain it is default .","title":"Setting Translation Files"},{"location":"translator/factory/#setting-remote-translations","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'remote_translation' => [ [ 'type' => 'translation-de_DE', // Custom name ], [ 'type' => 'translation-de_DE', // Custom name 'text_domain' => 'album', ], ], ]); Each remote option array must contain type . The option for text_domain is optional. The default value for text_domain is default .","title":"Setting Remote Translations"},{"location":"translator/factory/#setting-cache","text":"","title":"Setting Cache"},{"location":"translator/factory/#enable-eventmanager","text":"$translator = Laminas\\I18n\\Translator\\Translator::factory([ 'event_manager_enabled' => true, ]);","title":"Enable EventManager"},{"location":"translator/format-examples/","text":"Format Examples PHP For example languages/de_DE.php : return [ // Message => Translation 'car' => 'Auto', 'train' => 'Zug', ]; Plural For example languages/en_GB.php : return [ // Rule for English '' => [ 'plural_forms' => 'nplurals=2; plural=(n==1 ? 0 : 1)', ], // Messages 'car' => 'car', 'train' => 'train', ]; For example languages/fr_FR.php : return [ // Rule for French '' => [ 'plural_forms' => 'nplurals=2; plural=(n==0 || n==1 ? 0 : 1)', ], // Messages 'car' => 'voiture', 'train' => 'train', ]; INI Normal Syntax For example languages/de_DE.ini : ; Message identifier1.message = \"car\" ; Translation identifier1.translation = \"Auto\" identifier2.message = \"train\" identifier2.translation = \"Zug\" Simple Syntax For example languages/de_DE.ini : ; Message identifier1[] = \"car\" ; Translation identifier1[] = \"Auto\" identifier2[] = \"train\" identifier2[] = \"Zug\" Plural For example languages/en_GB.ini : [plural] plural_forms = 'nplurals=2; plural=(n==1 ? 0 : 1)' [translation] identifier1.message = \"car\" identifier1.translation = \"car\" identifier2.message = \"train\" identifier2.translation = \"train\" For example languages/fr_FR.ini : [plural] plural_forms = 'nplurals=2; plural=(n==0 || n==1 ? 0 : 1)' [translation] identifier1.message = \"car\" identifier1.translation = \"voiture\" identifier2.message = \"train\" identifier2.translation = \"train\"","title":"Format Examples"},{"location":"translator/format-examples/#format-examples","text":"","title":"Format Examples"},{"location":"translator/format-examples/#php","text":"For example languages/de_DE.php : return [ // Message => Translation 'car' => 'Auto', 'train' => 'Zug', ];","title":"PHP"},{"location":"translator/format-examples/#ini","text":"","title":"INI"},{"location":"validators/alnum/","text":"Alnum Laminas\\I18n\\Validator\\Alnum allows you to validate if a given value contains only alphabetical characters and digits . Basic Usage $validator = new Laminas\\I18n\\Validator\\Alnum(); if ($validator->isValid('Abcd12')) { // Value contains only allowed chars } Using Whitespace By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]); if ($validator->isValid('Abcd and 12')) { // Value contains only allowed chars } $validator = new Laminas\\I18n\\Validator\\Alnum(); $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and 12')) { // Value contains only allowed chars } Get Current Value To get the current value of this option, use the getAllowWhiteSpace() method. $validator = new Laminas\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]); $result = $validator->getAllowWhiteSpace(); // true Default Value The default value of this option is false that means whitespace characters are not allowed. Using different Languages Several languages supported by PHP's internationalization extension ( ext/intl ) use alphabets where characters are formed from multiple bytes, including Korean , Japanese , and Chinese . Such languages therefore are unsupported with regards to the Alnum validator. When using the Alnum validator with these languages, the input will be validated using the English alphabet.","title":"Alnum"},{"location":"validators/alnum/#alnum","text":"Laminas\\I18n\\Validator\\Alnum allows you to validate if a given value contains only alphabetical characters and digits .","title":"Alnum"},{"location":"validators/alnum/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\Alnum(); if ($validator->isValid('Abcd12')) { // Value contains only allowed chars }","title":"Basic Usage"},{"location":"validators/alnum/#using-whitespace","text":"By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\Alnum(['allowWhiteSpace' => true]); if ($validator->isValid('Abcd and 12')) { // Value contains only allowed chars } $validator = new Laminas\\I18n\\Validator\\Alnum(); $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and 12')) { // Value contains only allowed chars }","title":"Using Whitespace"},{"location":"validators/alnum/#using-different-languages","text":"Several languages supported by PHP's internationalization extension ( ext/intl ) use alphabets where characters are formed from multiple bytes, including Korean , Japanese , and Chinese . Such languages therefore are unsupported with regards to the Alnum validator. When using the Alnum validator with these languages, the input will be validated using the English alphabet.","title":"Using different Languages"},{"location":"validators/alpha/","text":"Alpha Laminas\\I18n\\Validator\\Alpha allows you to validate if a given value contains only alphabetical characters . This validator is identical to the Laminas\\I18n\\Validator\\Alnum validator with the exception that it does not accept digits. Basic Usage $validator = new Laminas\\I18n\\Validator\\Alpha(); if ($validator->isValid('Abcd')) { // Value contains only allowed chars } Using Whitespace By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]); if ($validator->isValid('Abcd and efg')) { // Value contains only allowed chars } $validator = new Laminas\\I18n\\Validator\\Alpha(); $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and efg')) { // Value contains only allowed chars } Get Current Value To get the current value of this option, use the getAllowWhiteSpace() method. $validator = new Laminas\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]); $result = $validator->getAllowWhiteSpace(); // true Default Value The default value of this option is false that means whitespace characters are not allowed. Using different Languages When using Laminas\\I18n\\Validator\\Alpha , the language provided by the user's browser will be used to set the allowed characters. For locales outside of English, this means that additional alphabetic characters may be used \u2014 such as \u00e4 , \u00f6 and \u00fc from the German alphabet. Which characters are allowed depends completely on the language, as every language defines its own set of characters. Three languages supported by PHP's internationalization extension ( ext/intl ), however, define multibyte characters, which cannot be matched as alphabetic characters using normal string or regular expression options. These include Korean , Japanese , and Chinese . As a result, when using the Alpha validator with these languages, the input will be validated using the English alphabet.","title":"Alpha"},{"location":"validators/alpha/#alpha","text":"Laminas\\I18n\\Validator\\Alpha allows you to validate if a given value contains only alphabetical characters . This validator is identical to the Laminas\\I18n\\Validator\\Alnum validator with the exception that it does not accept digits.","title":"Alpha"},{"location":"validators/alpha/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\Alpha(); if ($validator->isValid('Abcd')) { // Value contains only allowed chars }","title":"Basic Usage"},{"location":"validators/alpha/#using-whitespace","text":"By default, whitespace is not accepted as it is not part of the alphabet. However, if you want to validate complete sentences or phrases, you may need to allow whitespace; this can be done via the allowWhiteSpace option, either at instantiation or afterwards via the setAllowWhiteSpace() method. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\Alpha(['allowWhiteSpace' => true]); if ($validator->isValid('Abcd and efg')) { // Value contains only allowed chars } $validator = new Laminas\\I18n\\Validator\\Alpha(); $validator->setAllowWhiteSpace(true); if ($validator->isValid('Abcd and efg')) { // Value contains only allowed chars }","title":"Using Whitespace"},{"location":"validators/alpha/#using-different-languages","text":"When using Laminas\\I18n\\Validator\\Alpha , the language provided by the user's browser will be used to set the allowed characters. For locales outside of English, this means that additional alphabetic characters may be used \u2014 such as \u00e4 , \u00f6 and \u00fc from the German alphabet. Which characters are allowed depends completely on the language, as every language defines its own set of characters. Three languages supported by PHP's internationalization extension ( ext/intl ), however, define multibyte characters, which cannot be matched as alphabetic characters using normal string or regular expression options. These include Korean , Japanese , and Chinese . As a result, when using the Alpha validator with these languages, the input will be validated using the English alphabet.","title":"Using different Languages"},{"location":"validators/date-time/","text":"DateTime Laminas\\I18n\\Validator\\DateTime allows you to determine if a given value is a valid date, time or datetime . Internally, PHP's IntlDateFormatter tries to create a date time for the given value. Basic Usage $validator = new Laminas\\I18n\\Validator\\DateTime(); var_dump($validator->isValid('20190228 10:00 pm')); // true var_dump($validator->isValid('20190229 10:00 pm')); // false var_dump($validator->isValid('20200229 10:00 pm')); // true By default, if no locale is provided, DateTime will use the system locale provided by PHP's Locale::getDefault() and the default timezone provided by PHP's date_default_timezone_get . (The above example assumes that the environment locale is set to en_EN and the timezone is set to Europe/London .) Set Locale Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['locale' => 'de']); var_dump($validator->isValid('29.02.2020')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setLocale('de'); var_dump($validator->isValid('29.02.2020')); // true Get Current Value To get the current value of this option, use the getLocale() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['locale' => 'en_US']); echo $validator->getLocale(); // 'en_US' Default Value By default, if no locale is provided, DateTime will use the system locale provided by PHP's Locale::getDefault() . Define Custom Pattern Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['pattern' => 'yyyy-MM-DD']); var_dump($validator->isValid('2019-02-28')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setPattern('yyyy-MM-DD'); var_dump($validator->isValid('2019-02-28')); // true Possible patterns are documented at http://userguide.icu-project.org/formatparse/datetime . Get Current Value To get the current value of this option, use the getPattern() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['pattern' => 'yyyy-MM-DD']); echo $validator->getPattern(); // 'yyyy-MM-DD' Default Value The default value of this option is null . Using Date Type Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['date_type' => IntlDateFormatter::MEDIUM]); var_dump($validator->isValid('Feb 28, 2020')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setDateType(IntlDateFormatter::MEDIUM); var_dump($validator->isValid('Feb 28, 2020')); // true Possible values for the date type option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::NONE - Do not include this element IntlDateFormatter::FULL - Fullstyle (Tuesday, April 12, 1952 AD) IntlDateFormatter::LONG - Long style (January 12, 1952) IntlDateFormatter::MEDIUM - Medium style (Jan 12, 1952) IntlDateFormatter::SHORT - Short style (12/13/52) Get Current Value To get the current value of this option, use the getDateType() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['date_type' => IntlDateFormatter::MEDIUM]); echo $validator->getDateType(); // 'MMM d, y' (IntlDateFormatter::MEDIUM) Default Value The default value of this option is IntlDateFormatter::NONE . Using Time Type Sets time type to use (none, short, medium, long, full). Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['time_type' => IntlDateFormatter::MEDIUM]); var_dump($validator->isValid('8:05:40 pm')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setTimeType(IntlDateFormatter::MEDIUM); var_dump($validator->isValid('8:05:40 pm')); // true Possible values for the date type option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::NONE - Do not include this element IntlDateFormatter::FULL - Fullstyle (3:30:42pm PST) IntlDateFormatter::LONG - Long style (3:30:32pm) IntlDateFormatter::MEDIUM - Medium style (3:30:32pm) IntlDateFormatter::SHORT - Short style (3:30pm) Get Current Value To get the current value of this option, use the getTimeType() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['time_type' => IntlDateFormatter::MEDIUM]); echo $validator->getTimeType(); // 'h:mm:ss a' (IntlDateFormatter::MEDIUM) Default Value The default value of this option is IntlDateFormatter::NONE . Using Calendar To demonstrate the calendar option, additional settings are needed. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime([ 'calendar' => IntlDateFormatter::TRADITIONAL, 'date_type' => IntlDateFormatter::MEDIUM, 'locale' => 'de_DE@calendar=buddhist', 'timezone' => 'Europe/Berlin', ]); var_dump($validator->isValid('28.02.2562 BE')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setCalendar(IntlDateFormatter::TRADITIONAL); $validator->setDateType(IntlDateFormatter::MEDIUM); $validator->setLocale('de_DE@calendar=buddhist'); $validator->setTimezone('Europe/Berlin'); var_dump($validator->isValid('28.02.2562 BE')); // true Possible values for the calendar option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::TRADITIONAL - Non-Gregorian Calendar IntlDateFormatter::GREGORIAN - Gregorian Calendar Get Current Value To get the current value of this option, use the getCalendar() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['calendar' => IntlDateFormatter::TRADITIONAL]); echo $validator->getCalendar(); // '0' (IntlDateFormatter::TRADITIONAL) Default Value The default value of this option is IntlDateFormatter::GREGORIAN . Using Timezone Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['timezone' => 'Europe/London']); var_dump($validator->isValid('20190228 10:00 pm')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setTimezone('Europe/London'); var_dump($validator->isValid('20190228 10:00 pm')); // true Get Current Value To get the current value of this option, use the getTimezone() method. $validator = new Laminas\\I18n\\Validator\\DateTime(['timezone' => 'Europe/London']); echo $validator->getTimezone(); // 'Europe/London' Default Value By default, if no timezone is provided, DateTime will use the system timezone provided by PHP's date_default_timezone_get() .","title":"DateTime"},{"location":"validators/date-time/#datetime","text":"Laminas\\I18n\\Validator\\DateTime allows you to determine if a given value is a valid date, time or datetime . Internally, PHP's IntlDateFormatter tries to create a date time for the given value.","title":"DateTime"},{"location":"validators/date-time/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\DateTime(); var_dump($validator->isValid('20190228 10:00 pm')); // true var_dump($validator->isValid('20190229 10:00 pm')); // false var_dump($validator->isValid('20200229 10:00 pm')); // true By default, if no locale is provided, DateTime will use the system locale provided by PHP's Locale::getDefault() and the default timezone provided by PHP's date_default_timezone_get . (The above example assumes that the environment locale is set to en_EN and the timezone is set to Europe/London .)","title":"Basic Usage"},{"location":"validators/date-time/#set-locale","text":"Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['locale' => 'de']); var_dump($validator->isValid('29.02.2020')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setLocale('de'); var_dump($validator->isValid('29.02.2020')); // true","title":"Set Locale"},{"location":"validators/date-time/#define-custom-pattern","text":"Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['pattern' => 'yyyy-MM-DD']); var_dump($validator->isValid('2019-02-28')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setPattern('yyyy-MM-DD'); var_dump($validator->isValid('2019-02-28')); // true Possible patterns are documented at http://userguide.icu-project.org/formatparse/datetime .","title":"Define Custom Pattern"},{"location":"validators/date-time/#using-date-type","text":"Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['date_type' => IntlDateFormatter::MEDIUM]); var_dump($validator->isValid('Feb 28, 2020')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setDateType(IntlDateFormatter::MEDIUM); var_dump($validator->isValid('Feb 28, 2020')); // true Possible values for the date type option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::NONE - Do not include this element IntlDateFormatter::FULL - Fullstyle (Tuesday, April 12, 1952 AD) IntlDateFormatter::LONG - Long style (January 12, 1952) IntlDateFormatter::MEDIUM - Medium style (Jan 12, 1952) IntlDateFormatter::SHORT - Short style (12/13/52)","title":"Using Date Type"},{"location":"validators/date-time/#using-time-type","text":"Sets time type to use (none, short, medium, long, full). Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['time_type' => IntlDateFormatter::MEDIUM]); var_dump($validator->isValid('8:05:40 pm')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setTimeType(IntlDateFormatter::MEDIUM); var_dump($validator->isValid('8:05:40 pm')); // true Possible values for the date type option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::NONE - Do not include this element IntlDateFormatter::FULL - Fullstyle (3:30:42pm PST) IntlDateFormatter::LONG - Long style (3:30:32pm) IntlDateFormatter::MEDIUM - Medium style (3:30:32pm) IntlDateFormatter::SHORT - Short style (3:30pm)","title":"Using Time Type"},{"location":"validators/date-time/#using-calendar","text":"To demonstrate the calendar option, additional settings are needed. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime([ 'calendar' => IntlDateFormatter::TRADITIONAL, 'date_type' => IntlDateFormatter::MEDIUM, 'locale' => 'de_DE@calendar=buddhist', 'timezone' => 'Europe/Berlin', ]); var_dump($validator->isValid('28.02.2562 BE')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setCalendar(IntlDateFormatter::TRADITIONAL); $validator->setDateType(IntlDateFormatter::MEDIUM); $validator->setLocale('de_DE@calendar=buddhist'); $validator->setTimezone('Europe/Berlin'); var_dump($validator->isValid('28.02.2562 BE')); // true Possible values for the calendar option are the following constants of PHP's IntlDateFormatter class : IntlDateFormatter::TRADITIONAL - Non-Gregorian Calendar IntlDateFormatter::GREGORIAN - Gregorian Calendar","title":"Using Calendar"},{"location":"validators/date-time/#using-timezone","text":"Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\DateTime(['timezone' => 'Europe/London']); var_dump($validator->isValid('20190228 10:00 pm')); // true $validator = new Laminas\\I18n\\Validator\\DateTime(); $validator->setTimezone('Europe/London'); var_dump($validator->isValid('20190228 10:00 pm')); // true","title":"Using Timezone"},{"location":"validators/introduction/","text":"Introduction laminas-i18n provides a set of validators that use internationalization capabilities. Alnum Alpha DateTime IsFloat IsInt PhoneNumber PostCode These validators are based on Laminas component for validation of data and files: laminas-validator . The documentation of laminas-validator also describes the translate of the validation messages . Installation requirements The validation support of laminas-i18n depends on the laminas-validator component, so be sure to have it installed before getting started: $$$$FENCED_CODE_BLOCK_5e70df4c290119.64372981","title":"Introduction"},{"location":"validators/introduction/#introduction","text":"laminas-i18n provides a set of validators that use internationalization capabilities. Alnum Alpha DateTime IsFloat IsInt PhoneNumber PostCode These validators are based on Laminas component for validation of data and files: laminas-validator . The documentation of laminas-validator also describes the translate of the validation messages .","title":"Introduction"},{"location":"validators/is-float/","text":"IsFloat Laminas\\I18n\\Validator\\IsFloat allows you to validate if a given value contains a floating-point value . This validator takes into account localized input. Float values are often written differently based on the country or region. For example, using English, you might write 1.5 , whereas in german you would write 1,5 , and in other languages you might use grouping. Laminas\\I18n\\Validator\\IsFloat is able to validate such notations. However, it is limited to the locale you set. Basic Usage $validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // true $validator->isValid('10a01'); // false $validator->isValid('1,234.5'); // true By default, if no locale is provided, IsFloat will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to en .) Using a notation not specific to the locale results in a false evaluation. Using Locale Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\IsFloat(['locale' => 'en_US']); $validator->isValid(1234.5); // true $validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->setLocale('en_US'); $validator->isValid(1234.5); // true Locale::setDefault('en_US'); $validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // true Get Current Value To get the current value of this option, use the getLocale() method. $validator = new Laminas\\I18n\\Validator\\IsFloat(['locale' => 'en_US']); echo $validator->getLocale(); // 'en_US' Default Value By default, if no locale is provided, IsFloat will use the system locale provided by PHP's Locale::getDefault() .","title":"IsFloat"},{"location":"validators/is-float/#isfloat","text":"Laminas\\I18n\\Validator\\IsFloat allows you to validate if a given value contains a floating-point value . This validator takes into account localized input. Float values are often written differently based on the country or region. For example, using English, you might write 1.5 , whereas in german you would write 1,5 , and in other languages you might use grouping. Laminas\\I18n\\Validator\\IsFloat is able to validate such notations. However, it is limited to the locale you set.","title":"IsFloat"},{"location":"validators/is-float/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // true $validator->isValid('10a01'); // false $validator->isValid('1,234.5'); // true By default, if no locale is provided, IsFloat will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to en .) Using a notation not specific to the locale results in a false evaluation.","title":"Basic Usage"},{"location":"validators/is-float/#using-locale","text":"Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\IsFloat(['locale' => 'en_US']); $validator->isValid(1234.5); // true $validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->setLocale('en_US'); $validator->isValid(1234.5); // true Locale::setDefault('en_US'); $validator = new Laminas\\I18n\\Validator\\IsFloat(); $validator->isValid(1234.5); // true","title":"Using Locale"},{"location":"validators/is-int/","text":"IsInt Laminas\\I18n\\Validator\\IsInt validates if a given value is an integer , using the locale provided. Integer values are often written differently based on country or region. For example, using English, you may write 1234 or 1,234 ; both are integer values, but the grouping is optional. In German, you'd write 1.234 , and in French, 1 234 . Laminas\\I18n\\Validator\\IsInt will use a provided locale when evaluating the validity of an integer value. In such cases, it doesn't simply strip the separator, but instead validates that the correct separator as defined by used locale. Basic Usage $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid(1234.5); // returns false $validator->isValid('1,234'); // returns true By default, if no locale is provided, IsInt will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to en .) Using a notation not specific to the locale results in a false evaulation. Using Locale Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\IsInt(['locale' => 'en_US']); $validator->isValid(1234); // true $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->setLocale('en_US'); $validator->isValid(1234); // true Locale::setDefault('en_US'); $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // true Get Current Value To get the current value of this option, use the getLocale() method. $validator = new Laminas\\I18n\\Validator\\IsInt(['locale' => 'en_US']); echo $validator->getLocale(); // 'en_US' Default Value By default, if no locale is provided, IsInt will use the system locale provided by PHP's Locale::getDefault() . Strict Validation By default, the value's data type is not enforced. $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // true $validator->isValid('1234'); // true To enforced a strict validation set the strict option to true . Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\IsInt(['strict' => true]); $validator->isValid(1234); // true $validator->isValid('1234'); // false $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->setStrict(true) $validator->isValid(1234); // true $validator->isValid('1234'); // false Get Current Value To get the current value of this option, use the getStrict() method. $validator = new Laminas\\I18n\\Validator\\IsInt(['strict' => true]); echo $validator->getStrict(); // true Default Value The default value of this option is false .","title":"IsInt"},{"location":"validators/is-int/#isint","text":"Laminas\\I18n\\Validator\\IsInt validates if a given value is an integer , using the locale provided. Integer values are often written differently based on country or region. For example, using English, you may write 1234 or 1,234 ; both are integer values, but the grouping is optional. In German, you'd write 1.234 , and in French, 1 234 . Laminas\\I18n\\Validator\\IsInt will use a provided locale when evaluating the validity of an integer value. In such cases, it doesn't simply strip the separator, but instead validates that the correct separator as defined by used locale.","title":"IsInt"},{"location":"validators/is-int/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // returns true $validator->isValid(1234.5); // returns false $validator->isValid('1,234'); // returns true By default, if no locale is provided, IsInt will use the system locale provided by PHP's Locale class and the getDefault() method. (The above example assumes that the environment locale is set to en .) Using a notation not specific to the locale results in a false evaulation.","title":"Basic Usage"},{"location":"validators/is-int/#using-locale","text":"Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\IsInt(['locale' => 'en_US']); $validator->isValid(1234); // true $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->setLocale('en_US'); $validator->isValid(1234); // true Locale::setDefault('en_US'); $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // true","title":"Using Locale"},{"location":"validators/is-int/#strict-validation","text":"By default, the value's data type is not enforced. $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->isValid(1234); // true $validator->isValid('1234'); // true To enforced a strict validation set the strict option to true . Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\IsInt(['strict' => true]); $validator->isValid(1234); // true $validator->isValid('1234'); // false $validator = new Laminas\\I18n\\Validator\\IsInt(); $validator->setStrict(true) $validator->isValid(1234); // true $validator->isValid('1234'); // false","title":"Strict Validation"},{"location":"validators/phone-number/","text":"PhoneNumber Laminas\\I18n\\Validator\\PhoneNumber allows you to determine if a given value is a valid phone number . Phone numbers are specific to country codes. Basic Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); var_dump($validator->isValid('+4930123456')); // true By default, if no country code is provided, PhoneNumber will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the country code. (The above example assumes that the environment locale is set to de_DE .) Using Country The ISO 3611 country code can be set for validations. Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber(['country' => 'DE']); var_dump($validator->isValid('+4930123456')); // true $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->setCountry('DE'); var_dump($validator->isValid('+4930123456')); // true Locale::setDefault('de_DE'); $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); var_dump($validator->isValid('+4930123456')); // true Get Current Value To get the current value of this option, use the getCountry() method. $validator = new Laminas\\I18n\\Validator\\PhoneNumber(['country' => 'US']); echo $validator->getCountry(); // 'US' Default Value By default, if no country is provided, PhoneNumber will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the region code. Using Allowed Phone Number Patterns Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'allowed_types' => ['emergency'], 'country' => 'US', ]); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // false $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->allowedTypes(['emergency']); $validator->setCountry('US'); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // false Possible values for allowed patterns are: emergency fixed general mobile pager personal premium shared shortcode tollfree uan voicemail voip All allowed patterns The complete list of allowed patterns is not available for each country code. Please check the file for your country code with the supported types in the laminas-i18n repository on GitHub or in the vendor/laminas/laminas-i18n/src/Validator/PhoneNumber directory of your project folder. Get Current Value To get the current value of this option, use the allowedTypes() method with the value null . $validator = new Laminas\\I18n\\Validator\\PhoneNumber(['allowed_types' => ['emergency']]); var_dump($validator->allowedTypes()); // ['emergency'] Default Value The following phone number patterns are allowed per default: fixed general mobile personal tollfree uan voip Strict Validation By default, the phone numbers are validated against strict number patterns. To allow validation with all possible phone numbers, the allow_possible option can be used. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'allow_possible' => true, 'allowed_types' => ['emergency'], 'country' => 'US', ]); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // true var_dump($validator->isValid(9999)); // false $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->allowPossible(true); $validator->allowedTypes(['emergency']); $validator->setCountry('US'); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // true var_dump($validator->isValid(9999)); // false Get Current Value To get the current value of this option, use the allowPossible() method with the value null . $validator = new Laminas\\I18n\\Validator\\PhoneNumber(['allow_possible' => true]); var_dump($validator->allowPossible()); // true Default Value The default value of this option is false . Specify Country Code on Validation The country code can be specified with the context parameter on the isValid method. This allows to validate phone numbers for different country codes with the same validator instance without the usage of the setCountry() method. $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'country' => 'country-code', // Defines a placeholder ]); var_dump($validator->isValid('+37067811268', ['country-code' => 'LT'])); // true var_dump($validator->isValid('+37067811268', ['country-code' => 'DE'])); // false var_dump($validator->isValid('+37067811268', ['country-code' => 'US'])); // false","title":"PhoneNumber"},{"location":"validators/phone-number/#phonenumber","text":"Laminas\\I18n\\Validator\\PhoneNumber allows you to determine if a given value is a valid phone number . Phone numbers are specific to country codes.","title":"PhoneNumber"},{"location":"validators/phone-number/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\PhoneNumber(); var_dump($validator->isValid('+4930123456')); // true By default, if no country code is provided, PhoneNumber will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the country code. (The above example assumes that the environment locale is set to de_DE .)","title":"Basic Usage"},{"location":"validators/phone-number/#using-country","text":"The ISO 3611 country code can be set for validations. Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber(['country' => 'DE']); var_dump($validator->isValid('+4930123456')); // true $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->setCountry('DE'); var_dump($validator->isValid('+4930123456')); // true Locale::setDefault('de_DE'); $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); var_dump($validator->isValid('+4930123456')); // true","title":"Using Country"},{"location":"validators/phone-number/#using-allowed-phone-number-patterns","text":"Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'allowed_types' => ['emergency'], 'country' => 'US', ]); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // false $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->allowedTypes(['emergency']); $validator->setCountry('US'); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // false Possible values for allowed patterns are: emergency fixed general mobile pager personal premium shared shortcode tollfree uan voicemail voip","title":"Using Allowed Phone Number Patterns"},{"location":"validators/phone-number/#strict-validation","text":"By default, the phone numbers are validated against strict number patterns. To allow validation with all possible phone numbers, the allow_possible option can be used. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'allow_possible' => true, 'allowed_types' => ['emergency'], 'country' => 'US', ]); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // true var_dump($validator->isValid(9999)); // false $validator = new Laminas\\I18n\\Validator\\PhoneNumber(); $validator->allowPossible(true); $validator->allowedTypes(['emergency']); $validator->setCountry('US'); var_dump($validator->isValid(911)); // true var_dump($validator->isValid(999)); // true var_dump($validator->isValid(9999)); // false","title":"Strict Validation"},{"location":"validators/phone-number/#specify-country-code-on-validation","text":"The country code can be specified with the context parameter on the isValid method. This allows to validate phone numbers for different country codes with the same validator instance without the usage of the setCountry() method. $validator = new Laminas\\I18n\\Validator\\PhoneNumber([ 'country' => 'country-code', // Defines a placeholder ]); var_dump($validator->isValid('+37067811268', ['country-code' => 'LT'])); // true var_dump($validator->isValid('+37067811268', ['country-code' => 'DE'])); // false var_dump($validator->isValid('+37067811268', ['country-code' => 'US'])); // false","title":"Specify Country Code on Validation"},{"location":"validators/post-code/","text":"PostCode Laminas\\I18n\\Validator\\PostCode allows you to determine if a given value is a valid postal code . Postal codes are specific to cities, and in some locales termed ZIP codes. Laminas\\I18n\\Validator\\PostCode knows more than 160 different postal code formats. To select the correct format there are two ways. You can either use a fully qualified locale, or you can set your own format manually. Basic Usage $validator = new Laminas\\I18n\\Validator\\PostCode(); var_dump($validator->isValid(1010)); // true By default, if no country code is provided, PostCode will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the region code. (The above example assumes that the environment locale is set to de_AT .) Using Locale Using a locale is more convenient as laminas-validator already knows the appropriate postal code format for each locale; however, you need to use the fully qualified locale (one containing a region specifier) to do so. For instance, the locale de is a locale but could not be used with Laminas\\I18n\\Validator\\PostCode as it does not include the region; de_AT , however, would be a valid locale, as it specifies the region code ( AT , for Austria). Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\PostCode(['locale' => 'de_AT']); var_dump($validator->isValid(1010)); // true $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setLocale('de_AT'); $validator->isValid(1010); // true Locale::setDefault('de_AT'); $validator = new Laminas\\I18n\\Validator\\PostCode(); var_dump($validator->isValid(1010)); // true Get Current Value To get the current value of this option, use the getLocale() method. $validator = new Laminas\\I18n\\Validator\\PostCode(['locale' => 'de_AT']); echo $validator->getLocale(); // 'de_AT' Default Value By default, if no locale is provided, PostCode will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the region code. Using Custom Format Postal code formats are regular expression strings. When the international postal code format, which is used by setting the locale, does not fit your needs, then you can also manually set a format by calling setFormat() . Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PostCode(['format' => 'AT-\\d{4}']); var_dump($validator->isValid('AT-1010')); // true $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setFormat('AT-\\d{4}'); var_dump($validator->isValid('AT-1010')); // true Conventions for self defined Formats When using self defined formats, you should omit the regex delimiters and anchors ( '/^' and '$/' ). They are attached automatically. You should also be aware that postcode values will always be validated in a strict way. This means that they have to be written standalone without additional characters when they are not covered by the format. Get Current Value To get the current value of this option, use the getLocale() method. $validator = new Laminas\\I18n\\Validator\\PostCode(['format' => 'AT-\\d{4}']); echo $validator->getFormat(); // 'AT-\\d{4}' Default Value The default value of this option is null . Using Callback Service The PostCode validator allows additional validations via an optional service callback. The callback runs before the standard validation of the PostCode class. Internally, the additional validation is done by laminas-validator's Callback class. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PostCode([ 'service' => static function ($value) { // Allow only certain districts in town if (in_array($value, range(1010, 1423), false)) { return true; } return false; }, 'locale' => 'de_AT', ]); var_dump($validator->isValid(1010)); // true var_dump($validator->isValid(1600)); // false $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setService(static function ($value) { // Allow only certain districts in town if (in_array($value, range(1010, 1423), false)) { return true; } return false; }); $validator->setLocale('de_AT'); var_dump($validator->isValid(1010)); // true var_dump($validator->isValid(1600)); // false Default Value The default value of this option is null .","title":"PostCode"},{"location":"validators/post-code/#postcode","text":"Laminas\\I18n\\Validator\\PostCode allows you to determine if a given value is a valid postal code . Postal codes are specific to cities, and in some locales termed ZIP codes. Laminas\\I18n\\Validator\\PostCode knows more than 160 different postal code formats. To select the correct format there are two ways. You can either use a fully qualified locale, or you can set your own format manually.","title":"PostCode"},{"location":"validators/post-code/#basic-usage","text":"$validator = new Laminas\\I18n\\Validator\\PostCode(); var_dump($validator->isValid(1010)); // true By default, if no country code is provided, PostCode will use the system locale provided by PHP's Locale::getDefault() and Locale::getRegion() to extract the region code. (The above example assumes that the environment locale is set to de_AT .)","title":"Basic Usage"},{"location":"validators/post-code/#using-locale","text":"Using a locale is more convenient as laminas-validator already knows the appropriate postal code format for each locale; however, you need to use the fully qualified locale (one containing a region specifier) to do so. For instance, the locale de is a locale but could not be used with Laminas\\I18n\\Validator\\PostCode as it does not include the region; de_AT , however, would be a valid locale, as it specifies the region code ( AT , for Austria). Constructor Usage Setter Usage Locale Class Usage $validator = new Laminas\\I18n\\Validator\\PostCode(['locale' => 'de_AT']); var_dump($validator->isValid(1010)); // true $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setLocale('de_AT'); $validator->isValid(1010); // true Locale::setDefault('de_AT'); $validator = new Laminas\\I18n\\Validator\\PostCode(); var_dump($validator->isValid(1010)); // true","title":"Using Locale"},{"location":"validators/post-code/#using-custom-format","text":"Postal code formats are regular expression strings. When the international postal code format, which is used by setting the locale, does not fit your needs, then you can also manually set a format by calling setFormat() . Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PostCode(['format' => 'AT-\\d{4}']); var_dump($validator->isValid('AT-1010')); // true $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setFormat('AT-\\d{4}'); var_dump($validator->isValid('AT-1010')); // true","title":"Using Custom Format"},{"location":"validators/post-code/#using-callback-service","text":"The PostCode validator allows additional validations via an optional service callback. The callback runs before the standard validation of the PostCode class. Internally, the additional validation is done by laminas-validator's Callback class. Constructor Usage Setter Usage $validator = new Laminas\\I18n\\Validator\\PostCode([ 'service' => static function ($value) { // Allow only certain districts in town if (in_array($value, range(1010, 1423), false)) { return true; } return false; }, 'locale' => 'de_AT', ]); var_dump($validator->isValid(1010)); // true var_dump($validator->isValid(1600)); // false $validator = new Laminas\\I18n\\Validator\\PostCode(); $validator->setService(static function ($value) { // Allow only certain districts in town if (in_array($value, range(1010, 1423), false)) { return true; } return false; }); $validator->setLocale('de_AT'); var_dump($validator->isValid(1010)); // true var_dump($validator->isValid(1600)); // false","title":"Using Callback Service"}]}